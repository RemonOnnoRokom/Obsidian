এবং এই বিষয়টি আমাদের একটি গুরুত্বপূর্ণ property-তে নিয়ে যায়, যেটা হলো **half eliminate করার ক্ষমতা**। বিষয়টা এমন: যদি কোনো element এর জন্য কোনো শর্ত true হয়, তাহলে সেটা হয় ওই element এর আগে সবগুলোর জন্য true হবে অথবা ওই element এর পরে সবগুলোর জন্য true হবে। উদাহরণ হিসেবে, যখন আমরা 500 এর সাথে 278 compare করেছিলাম, যেহেতু 500 > 278, তাই এটা true যে 500 এর পরের যেকোনো element ও 278 এর থেকে বড় হবে। এখানে একটা inequality কাজ করছে guessed element আর 278 এর মধ্যে। যদি guess করার সময় true হয়, তাহলে guess করার পরের যেকোনো element এর জন্যও true হবে, কারণ এগুলো ordered। এজন্য আমরা অনেকগুলো element একসাথে eliminate করতে পারি।


1. - কোনো ক্ষেত্রে true গুলোর পরে false গুলো থাকতে পারে, অথবা false গুলোর পরে true গুলো।
    
- মূল কথা হলো, একটা **continuous block এ false, তারপর continuous block এ true** থাকতে হবে, অথবা উল্টো।
    
- মাঝখানে false এর মধ্যে true বা true এর মধ্যে false থাকা যাবে না।
    

**এই ধারাবাহিকতা না থাকলে binary search কাজ করবে না।**


এভাবে যখন competitive programming বা optimization problem করবেন, তখন বুঝে নিন:  
1️⃣ **Solution space কোথায়?** (index নাকি value এর উপর binary search হবে)  
2️⃣ **Predicate কী হবে?** (যে function true/false return করবে)

এই দুইটি জিনিস ঠিক করতে পারলেই binary search দিয়ে complex problem গুলো efficiently solve করতে পারবেন।