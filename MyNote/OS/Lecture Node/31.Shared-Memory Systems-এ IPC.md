**Shared-Memory Systems-এ IPC**

Shared memory ব্যবহার করে inter-process communication (IPC) করতে হলে যোগাযোগকারী processes-গুলোকে একটি shared memory region স্থাপন করতে হয়। সাধারণত, একটি shared-memory region সেই process-এর address space-এ থাকে, যে process shared-memory segment তৈরি করে। অন্যান্য processes যারা এই shared-memory segment ব্যবহার করে যোগাযোগ করতে চায়, তাদের এটি নিজেদের address space-এ attach করতে হয়। মনে রাখুন, সাধারণভাবে operating system একটি process-কে অন্য process-এর memory access করা থেকে বিরত রাখে। Shared memory-র ক্ষেত্রে দুই বা ততোধিক process এই restriction অপসারণে সম্মত হয়। এরপর তারা shared area-তে data read এবং write করে তথ্য আদান-প্রদান করতে পারে। Data-র form এবং location এই processes-গুলিই নির্ধারণ করে; এগুলো operating system-এর নিয়ন্ত্রণে থাকে না। একই সাথে একই location-এ write না করার বিষয়টি নিশ্চিত করার দায়িত্বও processes-গুলোর।

**Chapter 3 Processes**

Cooperating processes-এর ধারণা বোঝাতে producer–consumer problem বিবেচনা করা যাক, যা cooperating processes-এর একটি সাধারণ paradigm। একটি producer process তথ্য উৎপন্ন করে, যা একটি consumer process দ্বারা consume করা হয়। উদাহরণস্বরূপ, একটি compiler assembly code produce করতে পারে, যা একটি assembler consume করে। assembler আবার object modules produce করতে পারে, যা loader consume করে। Producer–consumer problem client–server paradigm-এর জন্যও একটি উপযোগী metaphor প্রদান করে। আমরা সাধারণত server-কে producer এবং client-কে consumer হিসেবে ভাবি। উদাহরণস্বরূপ, একটি web server web content (যেমন HTML files এবং images) produce (অর্থাৎ provide) করে, যা client web browser দ্বারা consume (অর্থাৎ read) করা হয়, যখন resource-টি request করা হয়।

Producer–consumer problem-এর একটি solution shared memory ব্যবহার করে। Producer এবং consumer processes-কে concurrently run করতে দিতে হলে, এমন একটি buffer থাকতে হবে যেখানে producer items fill করবে এবং consumer items empty করবে। এই buffer একটি memory region-এ থাকবে যা producer এবং consumer processes উভয়ের দ্বারা shared। Producer একটি item produce করতে পারে, একই সময়ে consumer অন্য একটি item consume করতে পারে। Producer এবং consumer-কে synchronized হতে হবে, যাতে consumer এমন কোনো item consume করার চেষ্টা না করে যা এখনও produce করা হয়নি।

দুই ধরনের buffer ব্যবহার করা যেতে পারে। Unbounded buffer-এ buffer-এর আকারের উপর কোনো practical limit থাকে না। Consumer-কে নতুন items-এর জন্য অপেক্ষা করতে হতে পারে, কিন্তু producer সবসময় নতুন items produce করতে পারে। Bounded buffer-এ একটি fixed buffer size ধরা হয়। এই ক্ষেত্রে, buffer empty হলে consumer-কে অপেক্ষা করতে হয়, এবং buffer full হলে producer-কে অপেক্ষা করতে হয়।

এখন দেখা যাক bounded buffer কীভাবে shared memory ব্যবহার করে inter-process communication প্রদর্শন করে। নিচের variables-গুলো producer এবং consumer processes-এর মধ্যে shared একটি memory region-এ থাকে:
```c
#define BUFFER SIZE 10
typedef struct {
. . .
} item;
item buffer[BUFFER SIZE];
int in = 0;
int out = 0;

```

Shared buffer-টি একটি circular array হিসেবে implement করা হয়েছে, যেখানে দুটি logical pointers আছে: `in` এবং `out`। Variable `in` buffer-এর পরবর্তী free position-কে নির্দেশ করে; `out` buffer-এর প্রথম full position-কে নির্দেশ করে। `in == out` হলে buffer empty, এবং `((in + 1) % BUFFER SIZE) == out` হলে buffer full।

Producer process-এর code Figure 3.12-এ এবং consumer process-এর code Figure 3.13-এ দেখানো হয়েছে। Producer process-এর একটি local variable `next_produced` আছে, যেখানে নতুন produce করা item সংরক্ষণ করা হয়। Consumer process-এর একটি local variable `next_consumed` আছে, যেখানে consume করার item সংরক্ষণ করা হয়।

এই scheme-টি একই সময়ে buffer-এ সর্বোচ্চ `BUFFER SIZE − 1` টি item থাকতে দেয়। Exercise হিসেবে রেখে দেওয়া হলো এমন একটি solution দেওয়া, যেখানে একই সময়ে buffer-এ `BUFFER SIZE` টি item থাকতে পারে। Section 3.7.1-এ আমরা shared memory-র জন্য POSIX API ব্যাখ্যা করেছি।


