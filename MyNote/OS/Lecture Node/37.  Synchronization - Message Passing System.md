**3.6.2 Synchronization**

Processes-এর মধ্যে communication ঘটে `send()` এবং `receive()` primitives কল করার মাধ্যমে। প্রতিটি primitive implement করার জন্য বিভিন্ন design option থাকতে পারে। **Message passing** হতে পারে **blocking** অথবা **nonblocking**—এগুলোকে যথাক্রমে **synchronous** এবং **asynchronous** নামেও পরিচিত। (এই বই জুড়ে তুমি operating-system-এর বিভিন্ন algorithm-এর ক্ষেত্রে synchronous এবং asynchronous behavior-এর ধারণার সঙ্গে পরিচিত হবে।)

- **Blocking send**: Sending process তখন পর্যন্ত blocked থাকে, যতক্ষণ না messageটি receiving process অথবা mailbox দ্বারা receive করা হয়।
    
- **Nonblocking send**: Sending process message পাঠিয়ে সাথে সাথেই তার operation resume করে।
    
- **Blocking receive**: Receiver process তখন পর্যন্ত blocked থাকে, যতক্ষণ না একটি message available হয়।
    
- **Nonblocking receive**: Receiver হয় একটি valid message retrieve করে, অথবা একটি null value পায়।

```c
message next_produced;
while (true) {
    /* produce an item in next_produced */
    send(next_produced);
}
```

_Figure 3.14 The producer process using message passing._

`send()` এবং `receive()`-এর বিভিন্ন combination সম্ভব। যখন `send()` এবং `receive()`—উভয়ই **blocking**, তখন sender এবং receiver-এর মধ্যে একটি **rendezvous** ঘটে। **Producer–consumer problem**-এর solution খুব সহজ হয়ে যায়, যখন আমরা blocking `send()` এবং blocking `receive()` statements ব্যবহার করি। Producer কেবল blocking `send()` call করে এবং অপেক্ষা করে যতক্ষণ না messageটি receiver অথবা mailbox-এ deliver হয়। একইভাবে, consumer যখন `receive()` invoke করে, তখন সে block থাকে যতক্ষণ না একটি message available হয়। এই বিষয়টি **Figure 3.14** এবং **Figure 3.15**-এ illustrated করা হয়েছে।
